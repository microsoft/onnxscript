# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.
"""Basic rewrite rules for general optimization patterns.

This module contains fundamental optimization rules that are generally applicable
to most ONNX models, including cast elimination, transpose simplification,
shape operation fusion, and other common patterns.
"""

from __future__ import annotations

import onnx_ir as ir
from onnxscript.rewriter import _ir_utils as ir_utils
from onnxscript.rewriter import pattern as orp


class ScatterAll(orp.RewriteRuleClassBase):
    """Rewrite rule to eliminate redundant ScatterND operations.
    
    Identify ScatterND(data, indices, updates) where that can be replaced by Identity(updates).
    This is generated by the translation of `x[:, ...] = y` in PyTorch.
    The specific pattern is that the updated indices take the form [[0], ..., [S-1]] for the first dimension,
    where S is the size of the first dimension of the updated-data tensor.
    In effect, the scatter-update ends up being an assignment of a new value to the entire tensor.
    """

    def pattern(self, op, data, axis, transposed_data, updates):
        # Construct update-indices spanning an entire axis:
        shape = op.Shape(data, start=0)
        dim = op.Gather(shape, axis, axis=0)
        full_range = op.Range(0, dim, 1)
        full_range_2d = op.Unsqueeze(full_range, [-1])
        # The update is applied to the data transposed to bring the updated axis to the front:
        return op.ScatterND(transposed_data, full_range_2d, updates, reduction='none')

    def check(self, context, data, axis, transposed_data, **_):
        # Check that updated-indices represent the full range of the first dimension of the transposed data.
        # That is: check that the data.shape[axis] matches transposed_data.shape[0].
        axis_value = ir_utils.get_singleton_value(axis)
        if not isinstance(axis_value, int):
            # Cannot determine the axis statically, so we cannot apply this rule.
            return False
        shape = data.shape
        if not isinstance(shape, ir.Shape):
            # The data shape is not known, so we cannot apply this rule.
            return False
        updated_dim_value = shape[axis_value]
        transposed_data_shape = transposed_data.shape
        if not isinstance(transposed_data_shape, ir.Shape):
            # The transposed data shape is not known, so we cannot apply this rule.
            return False
        actual_dim_value = transposed_data_shape[0]
        if updated_dim_value != actual_dim_value:
            # The first dimension of the transposed data does not match the updated dimension,
            # so we cannot apply this rule.
            return False
        return True        

    def rewrite(self, op, updates, **_):
        return op.Identity(updates)

rule = ScatterAll.rule()