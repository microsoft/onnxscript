# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.
"""Rewrite rule to eliminate redundant ScatterND operations.

Identify ScatterND(data, indices, updates) that can be replaced by Identity(updates).
This is generated by the translation of `x[:, ...] = y` in PyTorch.
The specific pattern is that the updated indices take the form [[0], ..., [S-1]] for the first dimension,
where S is the size of the first dimension of the updated-data tensor.
In effect, the scatter-update ends up being an assignment of a new value to the entire tensor.
"""

from __future__ import annotations

import onnx_ir as ir

import onnxscript.rewriter
from onnxscript.rewriter import _ir_utils as ir_utils
from onnxscript.rewriter import pattern as orp


def fail(*args):
    return onnxscript.rewriter.MatchResult().fail(*args)


class ScatterAll(orp.RewriteRuleClassBase):
    def pattern(self, op, data, axis, transposed_data, updates):
        # Construct update-indices spanning an entire axis:
        shape = op.Shape(data, start=0)
        dim = op.Gather(shape, axis, axis=0)
        full_range = op.Range(0, dim, 1)
        full_range_2d = op.Unsqueeze(full_range, [-1])
        # The update is applied to the data transposed to bring the updated axis to the front:
        return op.ScatterND(transposed_data, full_range_2d, updates, reduction="none")

    def check(self, context, data, axis, transposed_data, **_):
        # Check that updated-indices represent the full range of the first dimension of the transposed data.
        # That is: check that the data.shape[axis] matches transposed_data.shape[0].
        axis_value = ir_utils.get_singleton_value(axis)
        if not isinstance(axis_value, int):
            return fail("Axis value must be a constant integer.", axis)
        shape: ir.Shape | None = data.shape
        if shape is None:
            return fail("Data shape is not statically known.", data)
        updated_dim_value = shape[axis_value]
        transposed_data_shape: ir.Shape | None = transposed_data.shape
        if transposed_data_shape is None:
            return fail("Transposed data shape is not statically known.", transposed_data)
        actual_dim_value = transposed_data_shape[0]
        if updated_dim_value != actual_dim_value:
            # The first dimension of the transposed data does not match the updated dimension,
            # so we cannot apply this rule.
            return fail(
                "The first dimension of the transposed data does not match the updated dimension.",
                data,
                transposed_data,
            )
        return True

    def rewrite(self, op, updates, **_):
        return op.Identity(updates)


rule = ScatterAll.rule()

rules = orp.RewriteRuleSet([rule])
